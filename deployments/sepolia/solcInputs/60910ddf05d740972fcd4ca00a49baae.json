{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/shared/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  function approve(address spender, uint256 value) external returns (bool success);\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function decimals() external view returns (uint8 decimalPlaces);\n\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n\n  function name() external view returns (string memory tokenName);\n\n  function symbol() external view returns (string memory tokenSymbol);\n\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n\n  function transfer(address to, uint256 value) external returns (bool success);\n\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\n\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vrf/interfaces/VRFV2WrapperInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface VRFV2WrapperInterface {\n  /**\n   * @return the request ID of the most recent VRF V2 request made by this wrapper. This should only\n   * be relied option within the same transaction that the request was made.\n   */\n  function lastRequestId() external view returns (uint256);\n\n  /**\n   * @notice Calculates the price of a VRF request with the given callbackGasLimit at the current\n   * @notice block.\n   *\n   * @dev This function relies on the transaction gas price which is not automatically set during\n   * @dev simulation. To estimate the price at a specific gas price, use the estimatePrice function.\n   *\n   * @param _callbackGasLimit is the gas limit used to estimate the price.\n   */\n  function calculateRequestPrice(uint32 _callbackGasLimit) external view returns (uint256);\n\n  /**\n   * @notice Estimates the price of a VRF request with a specific gas limit and gas price.\n   *\n   * @dev This is a convenience function that can be called in simulation to better understand\n   * @dev pricing.\n   *\n   * @param _callbackGasLimit is the gas limit used to estimate the price.\n   * @param _requestGasPriceWei is the gas price in wei used for the estimation.\n   */\n  function estimateRequestPrice(uint32 _callbackGasLimit, uint256 _requestGasPriceWei) external view returns (uint256);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vrf/VRFV2WrapperConsumerBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {LinkTokenInterface} from \"../shared/interfaces/LinkTokenInterface.sol\";\nimport {VRFV2WrapperInterface} from \"./interfaces/VRFV2WrapperInterface.sol\";\n\n/** *******************************************************************************\n * @notice Interface for contracts using VRF randomness through the VRF V2 wrapper\n * ********************************************************************************\n * @dev PURPOSE\n *\n * @dev Create VRF V2 requests without the need for subscription management. Rather than creating\n * @dev and funding a VRF V2 subscription, a user can use this wrapper to create one off requests,\n * @dev paying up front rather than at fulfillment.\n *\n * @dev Since the price is determined using the gas price of the request transaction rather than\n * @dev the fulfillment transaction, the wrapper charges an additional premium on callback gas\n * @dev usage, in addition to some extra overhead costs associated with the VRFV2Wrapper contract.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFV2WrapperConsumerBase. The consumer must be funded\n * @dev with enough LINK to make the request, otherwise requests will revert. To request randomness,\n * @dev call the 'requestRandomness' function with the desired VRF parameters. This function handles\n * @dev paying for the request based on the current pricing.\n *\n * @dev Consumers must implement the fullfillRandomWords function, which will be called during\n * @dev fulfillment with the randomness result.\n */\nabstract contract VRFV2WrapperConsumerBase {\n  // solhint-disable-next-line chainlink-solidity/prefix-immutable-variables-with-i\n  LinkTokenInterface internal immutable LINK;\n  // solhint-disable-next-line chainlink-solidity/prefix-immutable-variables-with-i\n  VRFV2WrapperInterface internal immutable VRF_V2_WRAPPER;\n\n  /**\n   * @param _link is the address of LinkToken\n   * @param _vrfV2Wrapper is the address of the VRFV2Wrapper contract\n   */\n  constructor(address _link, address _vrfV2Wrapper) {\n    LINK = LinkTokenInterface(_link);\n    VRF_V2_WRAPPER = VRFV2WrapperInterface(_vrfV2Wrapper);\n  }\n\n  /**\n   * @dev Requests randomness from the VRF V2 wrapper.\n   *\n   * @param _callbackGasLimit is the gas limit that should be used when calling the consumer's\n   *        fulfillRandomWords function.\n   * @param _requestConfirmations is the number of confirmations to wait before fulfilling the\n   *        request. A higher number of confirmations increases security by reducing the likelihood\n   *        that a chain re-org changes a published randomness outcome.\n   * @param _numWords is the number of random words to request.\n   *\n   * @return requestId is the VRF V2 request ID of the newly created randomness request.\n   */\n  // solhint-disable-next-line chainlink-solidity/prefix-internal-functions-with-underscore\n  function requestRandomness(\n    uint32 _callbackGasLimit,\n    uint16 _requestConfirmations,\n    uint32 _numWords\n  ) internal returns (uint256 requestId) {\n    LINK.transferAndCall(\n      address(VRF_V2_WRAPPER),\n      VRF_V2_WRAPPER.calculateRequestPrice(_callbackGasLimit),\n      abi.encode(_callbackGasLimit, _requestConfirmations, _numWords)\n    );\n    return VRF_V2_WRAPPER.lastRequestId();\n  }\n\n  /**\n   * @notice fulfillRandomWords handles the VRF V2 wrapper response. The consuming contract must\n   * @notice implement it.\n   *\n   * @param _requestId is the VRF V2 request ID.\n   * @param _randomWords is the randomness result.\n   */\n  // solhint-disable-next-line chainlink-solidity/prefix-internal-functions-with-underscore\n  function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal virtual;\n\n  function rawFulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) external {\n    // solhint-disable-next-line gas-custom-errors\n    require(msg.sender == address(VRF_V2_WRAPPER), \"only VRF V2 wrapper can fulfill\");\n    fulfillRandomWords(_requestId, _randomWords);\n  }\n}\n"
    },
    "contracts/RandomIpfsNft.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\r\npragma solidity ^0.8.7;\r\n\r\nimport {VRFV2WrapperConsumerBase} from \"@chainlink/contracts/src/v0.8/vrf/VRFV2WrapperConsumerBase.sol\";\r\nimport {LinkTokenInterface} from \"@chainlink/contracts/src/v0.8/shared/interfaces/LinkTokenInterface.sol\";\r\n\r\ncontract VRFv2DirectFundingConsumer is\r\n    VRFV2WrapperConsumerBase\r\n{\r\n    event RequestSent(uint256 requestId, uint32 numWords);\r\n    event RequestFulfilled(\r\n        uint256 requestId,\r\n        uint256[] randomWords,\r\n        uint256 payment\r\n    );\r\n\r\n    struct RequestStatus {\r\n        uint256 paid;\r\n        bool fulfilled; \r\n        uint256[] randomWords;\r\n    }\r\n    mapping(uint256 => RequestStatus)\r\n        public s_requests;\r\n\r\n    uint256[] public requestIds;\r\n    uint256 public lastRequestId;\r\n\r\n    uint32 callbackGasLimit = 100000;\r\n\r\n    uint16 requestConfirmations = 3;\r\n\r\n    uint32 numWords = 1;\r\n\r\n    address linkAddress = 0x779877A7B0D9E8603169DdbD7836e478b4624789;\r\n\r\n    address wrapperAddress = 0xab18414CD93297B0d12ac29E63Ca20f515b3DB46;\r\n\r\n    constructor()\r\n        VRFV2WrapperConsumerBase(linkAddress, wrapperAddress)\r\n    {}\r\n\r\n    function requestRandomWords()\r\n        external\r\n        returns (uint256 requestId)\r\n    {\r\n        requestId = requestRandomness(\r\n            callbackGasLimit,\r\n            requestConfirmations,\r\n            numWords\r\n        );\r\n        s_requests[requestId] = RequestStatus({\r\n            paid: VRF_V2_WRAPPER.calculateRequestPrice(callbackGasLimit),\r\n            randomWords: new uint256[](0),\r\n            fulfilled: false\r\n        });\r\n        requestIds.push(requestId);\r\n        lastRequestId = requestId;\r\n        emit RequestSent(requestId, numWords);\r\n        return requestId;\r\n    }\r\n\r\n    function fulfillRandomWords(\r\n        uint256 _requestId,\r\n        uint256[] memory _randomWords\r\n    ) internal override {\r\n        require(s_requests[_requestId].paid > 0, \"request not found\");\r\n        s_requests[_requestId].fulfilled = true;\r\n        s_requests[_requestId].randomWords = _randomWords;\r\n        emit RequestFulfilled(\r\n            _requestId,\r\n            _randomWords,\r\n            s_requests[_requestId].paid\r\n        );\r\n    }\r\n\r\n    function getRequestStatus(\r\n        uint256 _requestId\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 paid, bool fulfilled, uint256[] memory randomWords)\r\n    {\r\n        require(s_requests[_requestId].paid > 0, \"request not found\");\r\n        RequestStatus memory request = s_requests[_requestId];\r\n        return (request.paid, request.fulfilled, request.randomWords);\r\n    }\r\n\r\n    /**\r\n     * Allow withdraw of Link tokens from the contract\r\n     */\r\n    function withdrawLink() public {\r\n        LinkTokenInterface link = LinkTokenInterface(linkAddress);\r\n        require(\r\n            link.transfer(msg.sender, link.balanceOf(address(this))),\r\n            \"Unable to transfer\"\r\n        );\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}